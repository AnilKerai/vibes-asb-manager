@inject IQueueAdmin QueueAdmin
@inject ITopicAdmin TopicAdmin
@inject ISubscriptionAdmin SubscriptionAdmin
@inject ISubscriptionRuleAdmin SubscriptionRuleAdmin
@inject IMessageBrowser MessageBrowser
@inject IMessageSender MessageSender
@inject IMessageMaintenance MessageMaintenance
@inject IDeadLetterMaintenance DeadLetterMaintenance
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<EntitiesView> Logger
@using Vibes.ASBManager.Application.Interfaces.Admin
@using Vibes.ASBManager.Application.Interfaces.Messaging
@using Vibes.ASBManager.Web.Models
@implements IDisposable

@if (_isLoading)
{
    <MudProgressLinear Indeterminate="true" Color="Color.Primary" />
}

@if (!_isLoading && _attemptedLoad && ((_queues?.Count ?? 0) == 0) && ((_topics?.Count ?? 0) == 0))
{
    <MudPaper Class="pa-6 mt-3 d-flex flex-column align-center justify-center" Elevation="1">
        <MudIcon Icon="@Icons.Material.Outlined.Inbox" Size="Size.Large" />
        <MudText Typo="Typo.h6" Class="mt-2">No entities</MudText>
        <MudText Typo="Typo.body2">We couldn't find any queues, topics, or subscriptions.</MudText>
    </MudPaper>
}

@if (!_isLoading && ((_queues?.Count ?? 0) > 0 || (_topics?.Count ?? 0) > 0))
{
    <MudGrid Class="mt-1">
        <MudItem xs="12" md="3">
            <ServiceBusTreePanel
                SelectedValue="@_selectedTreeValue"
                SelectedValueChanged="@OnTreeSelectionChanged"
                Queues="@_queues"
                Topics="@_topics"
                TopicSubscriptions="@_topicSubscriptions"
                QueuesExpanded="@_queuesExpanded"
                TopicsExpanded="@_topicsExpanded"
                ExpandedTopicNames="@_expandedTopicNames" />
        </MudItem>

        <MudItem xs="12" md="9">
            

            <EntitiesActionBar
                HasConnection="@HasConnection"
                CanLoad="@CanLoad"
                CanSend="@CanSend"
                CanPurgeActive="@CanPurgeActive"
                CanPurgeDlq="@CanPurgeDlq"
                CanResubmitDlq="@CanResubmitDlq"
                CanRefreshMessages="@CanRefreshMessages"
                CanCreateSubscriptionAction="@CanCreateSubscriptionAction"
                CanDeleteSubscriptionAction="@CanDeleteSubscriptionAction"
                SelectedIsRoot="@SelectedIsRoot"
                SelectedIsQueuesFolder="@SelectedIsQueuesFolder"
                SelectedIsTopicsFolder="@SelectedIsTopicsFolder"
                SelectedIsQueue="@SelectedIsQueue"
                SelectedIsTopic="@SelectedIsTopic"
                SelectedIsSubscription="@SelectedIsSubscription"
                LiveOn="@(_liveActive || _liveDlq)"
                OnRefresh="@RefreshEntities"
                OnSend="@SendToSelected"
                OnPurgeActive="@PurgeActiveSelected"
                OnPurgeDlq="@PurgeDlqSelected"
                OnResubmitDlq="@ResubmitDlqSelected"
                OnCreateQueue="@CreateQueueAsync"
                OnCreateTopic="@CreateTopicAsync"
                OnCreateSubscription="@CreateSubscriptionAsync"
                OnDeleteQueue="@DeleteSelectedQueueAsync"
                OnDeleteTopic="@DeleteSelectedTopicAsync"
                OnDeleteSubscription="@DeleteSelectedSubscriptionAsync"
                OnToggleLive="@ToggleLiveBothAsync" />

            <MudPaper Class="pa-2 mb-2 d-flex flex-wrap align-center" Elevation="1" Style="gap:8px;">
                <MudText Typo="Typo.subtitle2" Class="me-1">Namespace snapshot</MudText>
                <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined" Size="Size.Small">Queues: @FormatCount(QueueCount)</MudChip>
                <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined" Size="Size.Small">Topics: @FormatCount(TopicCount)</MudChip>
                <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined" Size="Size.Small">Subs: @FormatCount(SubscriptionCount)</MudChip>
                <MudChip T="string" Color="Color.Warning" Variant="Variant.Outlined" Size="Size.Small">DLQ: @FormatCount(TotalDlqCount)</MudChip>
                <MudChip T="string" Color="Color.Info" Variant="Variant.Outlined" Size="Size.Small">Scheduled: @FormatCount(TotalScheduledCount)</MudChip>
            </MudPaper>

            <EntitySettingsPanel
                IsSelectionValid="@(!string.IsNullOrEmpty(_selectedTreeValue) && (SelectedIsQueue || SelectedIsTopic || SelectedIsSubscription))"
                SelectedFriendly="@SelectedFriendly"
                TtlText="@_ttlText"
                TtlTextChanged="@((string value) => _ttlText = value)"
                DeadLetterOnExpiration="@_deadLetterOnExpiration"
                DeadLetterOnExpirationChanged="@((bool value) => _deadLetterOnExpiration = value)"
                ShowDeadLetterOnExpiration="@(SelectedIsQueue || SelectedIsSubscription)"
                SelectedIsQueue="@SelectedIsQueue"
                SelectedIsTopic="@SelectedIsTopic"
                SelectedIsSubscription="@SelectedIsSubscription"
                LockDurationText="@_lockDurationText"
                LockDurationTextChanged="@((string value) => _lockDurationText = value)"
                MaxDeliveryCount="@_maxDeliveryCount"
                MaxDeliveryCountChanged="@((int value) => _maxDeliveryCount = value)"
                EnableBatchedOperations="@_enableBatchedOperations"
                EnableBatchedOperationsChanged="@((bool value) => _enableBatchedOperations = value)"
                ForwardTo="@_forwardTo"
                ForwardToChanged="@((string? value) => _forwardTo = value)"
                ForwardDeadLetteredTo="@_forwardDeadLetteredTo"
                ForwardDeadLetteredToChanged="@((string? value) => _forwardDeadLetteredTo = value)"
                RequiresSession="@_requiresSession"
                RequiresSessionChanged="@((bool value) => _requiresSession = value)"
                SettingsLoading="@_settingsLoading"
                SettingsSaving="@_settingsSaving"
                CanSave="@CanSaveSettings"
                OnSave="@SaveSettingsAsync"
                OnReset="@ReloadSettingsAsync" />

            @if (SelectedIsSubscription)
            {
                <SubscriptionRulesPanel
                    Rules="@_rules"
                    IsLoading="@_rulesLoading"
                    CanRefresh="@CanRefreshRules"
                    OnCreateRule="@CreateRuleAsync"
                    OnRefresh="@RefreshRulesAsync"
                    OnDeleteRule="@DeleteRuleAsync" />
            }

            <MessageBrowserPanel
                ActiveItems="@_activeMessages"
                DlqItems="@_dlqMessages"
                CanRefresh="@CanRefreshMessages"
                ActiveCount="@_activeCount"
                DlqCount="@_dlqCount"
                OnActiveRefresh="@OnActiveRefresh"
                OnDlqRefresh="@OnDlqRefresh"
                OnActiveRowClick="@OnActiveRowClick"
                OnDlqRowClick="@OnDlqRowClick" />
        </MudItem>
    </MudGrid>
}

@code {
    [Parameter] public ConnectionInfo Connection { get; set; } = default!;

    private string? _connectionString;
    private string? _selectedTreeValue;
    private bool _isLoading;
    private bool _attemptedLoad;

    private IReadOnlyList<QueueSummary>? _queues;
    private IReadOnlyList<TopicSummary>? _topics;

    private Dictionary<string, IReadOnlyList<SubscriptionSummary>> _topicSubscriptions = new();


    private string? _prevConnectionId;

    // Subscription rules (filters)
    private bool _rulesLoading;
    private List<SubscriptionRuleInfo> _rules = new();

    // Tree folder expand state
    private bool _queuesExpanded;
    private bool _topicsExpanded;
    private HashSet<string> _expandedTopicNames = new();

    // Settings state
    private bool _settingsLoading;
    private bool _settingsSaving;
    private string _ttlText = string.Empty; // hh:mm:ss
    private bool _deadLetterOnExpiration;
    // Advanced settings state
    private string _lockDurationText = string.Empty; // hh:mm:ss
    private int _maxDeliveryCount;
    private bool _enableBatchedOperations;
    private string? _forwardTo;
    private string? _forwardDeadLetteredTo;
    private bool _requiresSession;

    private long? QueueCount => _queues is null ? null : _queues.Count;
    private long? TopicCount => _topics is null ? null : _topics.Count;
    private long? SubscriptionCount => _topics is null
        ? null
        : _topicSubscriptions.Sum(pair => pair.Value?.Count ?? 0);
    private long? TotalDlqCount => _queues is null && _topics is null
        ? null
        : (_queues?.Sum(queue => queue.DeadLetterMessageCount) ?? 0)
          + _topicSubscriptions.Sum(pair => pair.Value?.Sum(subscription => subscription.DeadLetterMessageCount) ?? 0);
    private long? TotalScheduledCount => _topics is null
        ? null
        : _topics.Sum(topic => topic.ScheduledMessageCount);

    // Messages view state lives in EntitiesView.MessageBrowser.cs

    // Create subscription state
    private bool _creatingSubscription;

    protected override async Task OnParametersSetAsync()
    {
        if (Connection?.Id != _prevConnectionId)
        {
            _prevConnectionId = Connection?.Id;
            ResetState();
            _attemptedLoad = true;
            if (CanLoad)
            {
                await LoadEntities();
            }
        }
    }

    private async Task DeleteSelectedSubscriptionAsync()
    {
        if (!HasConnection || !SelectedIsSubscription || string.IsNullOrWhiteSpace(_connectionString)) return;
        if (!TryGetSubscription(out var topicName, out var subName)) return;

        var confirm = await DialogService.ShowMessageBox(
            title: "Delete Subscription",
            markupMessage: (MarkupString)$"This will permanently delete subscription '<b>{topicName}/{subName}</b>' including its rules. Continue?",
            yesText: "Delete",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;

        try
        {
            await SubscriptionAdmin.DeleteSubscriptionAsync(_connectionString!, topicName, subName);
            Snackbar.Add($"Subscription '{topicName}/{subName}' deleted.", Severity.Success);
            // Refresh topic subscriptions
            var subs = await SubscriptionAdmin.ListSubscriptionsAsync(_connectionString!, topicName);
            _topicSubscriptions[topicName] = subs;
            // Select the topic and keep it expanded
            StopLiveActive();
            StopLiveDlq();
            _activeMessages.Clear();
            _dlqMessages.Clear();
            _expandedTopicNames.Add(topicName);
            _selectedTreeValue = $"topic:{topicName}";
            await LoadSettingsForSelection();
            await RefreshActiveAsync();
            await RefreshDlqAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete subscription: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmPurgeSubscription(string topicName, string subscriptionName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Purge Active Messages",
            markupMessage: (MarkupString)$"This will delete active messages from subscription '<b>{topicName}/{subscriptionName}</b>' (up to the configured batch). Continue?",
            yesText: "Purge",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var purged = await MessageMaintenance.PurgeSubscriptionAsync(connectionString, topicName, subscriptionName, maxMessages: 1000);
            Snackbar.Add($"Purged {purged} messages from {topicName}/{subscriptionName}.", Severity.Success);
            await ClearActiveAfterPurgeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to purge subscription: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmPurgeSubscriptionDlq(string topicName, string subscriptionName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Purge DLQ Messages",
            markupMessage: (MarkupString)$"This will delete messages from the Dead-letter subqueue of '<b>{topicName}/{subscriptionName}</b>' (up to the configured batch). Continue?",
            yesText: "Purge",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var purged = await DeadLetterMaintenance.PurgeSubscriptionDeadLetterAsync(connectionString, topicName, subscriptionName, maxMessages: 1000);
            Snackbar.Add($"Purged {purged} DLQ messages from {topicName}/{subscriptionName}.", Severity.Success);
            await ClearDlqAfterPurgeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to purge subscription DLQ: {ex.Message}", Severity.Error);
        }
    }

    private async Task ClearActiveAfterPurgeAsync()
    {
        _pendingActiveClear = true;
        _activeMessages.Clear();
        _activeAnchor = null;
        _activeHistory.Clear();
        try { await InvokeAsync(StateHasChanged); }
        catch (Exception ex)
        {
            Logger?.LogDebug(ex, "Failed to refresh UI after active purge.");
        }
        await RefreshActiveIfNeededAsync();
        await RefreshCountsAsync();
    }

    private async Task ClearDlqAfterPurgeAsync()
    {
        _pendingDlqClear = true;
        _dlqMessages.Clear();
        _dlqAnchor = null;
        _dlqHistory.Clear();
        try { await InvokeAsync(StateHasChanged); }
        catch (Exception ex)
        {
            Logger?.LogDebug(ex, "Failed to refresh UI after DLQ purge.");
        }
        await RefreshDlqIfNeededAsync();
        await RefreshCountsAsync();
    }

    private async Task RefreshAfterReplayAsync()
    {
        await RefreshActiveIfNeededAsync();
        await RefreshDlqIfNeededAsync();
        await RefreshCountsAsync();
    }

    private void ResetState()
    {
        _connectionString = Connection?.ConnectionString;
        StopLiveActive();
        StopLiveDlq();
        StopCountsPolling();
        _activeMessages.Clear();
        _dlqMessages.Clear();
        _activeAnchor = null;
        _dlqAnchor = null;
        _activeHistory.Clear();
        _dlqHistory.Clear();
        _activeCount = null;
        _dlqCount = null;
        _queues = null;
        _topics = null;




        _selectedTreeValue = null;
        _rules.Clear();
        _queuesExpanded = false;
        _topicsExpanded = false;
        _expandedTopicNames.Clear();
        // reset settings panel
        _ttlText = string.Empty;
        _deadLetterOnExpiration = false;
        _lockDurationText = string.Empty;
        _maxDeliveryCount = 10;
        _enableBatchedOperations = false;
        _forwardTo = null;
        _forwardDeadLetteredTo = null;
        _requiresSession = false;
    }

    private bool CanLoad => !string.IsNullOrWhiteSpace(_connectionString);

    private async Task LoadEntities()
    {
        if (string.IsNullOrWhiteSpace(_connectionString))
            return;
        try
        {
            _attemptedLoad = true;
            _isLoading = true;
            var queuesTask = QueueAdmin.ListQueuesAsync(_connectionString);
            var topicsTask = TopicAdmin.ListTopicsAsync(_connectionString);
            await Task.WhenAll(queuesTask, topicsTask);
            _queues = queuesTask.Result;
            _topics = topicsTask.Result;

            // Preload subscriptions for the tree view
            _topicSubscriptions = new();
            if (_topics is not null)
            {
                foreach (var t in _topics)
                {
                    try
                    {
                        var subs = await SubscriptionAdmin.ListSubscriptionsAsync(_connectionString, t.Name);
                        _topicSubscriptions[t.Name] = subs;
                    }
                    catch (Exception ex)
                    {
                        Logger?.LogWarning(ex, "Failed to load subscriptions for topic {TopicName}", t.Name);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load entities: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task OpenSendToQueue(string queueName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var connectionString = _connectionString!;
        await OpenSendDialogAsync(
            title: $"Send to queue '{queueName}'",
            targetName: queueName,
            sendAsync: (req, contentType, scheduled, cancellationToken) => MessageSender.SendToQueueAsync(
                connectionString: connectionString,
                queueName: queueName,
                body: req.Body,
                subject: req.Subject,
                correlationId: req.CorrelationId,
                properties: req.Properties,
                contentType: contentType,
                messageId: null,
                scheduledEnqueueTime: scheduled,
                cancellationToken: cancellationToken));
    }

    private async Task OpenSendToTopic(string topicName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var connectionString = _connectionString!;
        await OpenSendDialogAsync(
            title: $"Send to topic '{topicName}'",
            targetName: topicName,
            sendAsync: (req, contentType, scheduled, cancellationToken) => MessageSender.SendToTopicAsync(
                connectionString: connectionString,
                topicName: topicName,
                body: req.Body,
                subject: req.Subject,
                correlationId: req.CorrelationId,
                properties: req.Properties,
                contentType: contentType,
                messageId: null,
                scheduledEnqueueTime: scheduled,
                cancellationToken: cancellationToken));
    }

    private async Task OpenSendDialogAsync(string title, string targetName, Func<SendMessageRequest, string?, DateTimeOffset?, CancellationToken, Task> sendAsync)
    {
        var parameters = new DialogParameters
        {
            { "Title", title }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<SendMessageDialog>("Send", parameters, options);
        var result = await dialog.Result;
        if (result is { Canceled: false, Data: SendMessageRequest req })
        {
            await SendMessagesAsync(targetName, req, sendAsync);
        }
    }

    private async Task SendMessagesAsync(string targetName, SendMessageRequest req, Func<SendMessageRequest, string?, DateTimeOffset?, CancellationToken, Task> sendAsync)
    {
        var count = req.Count < 1 ? 1 : req.Count;
        var contentType = string.IsNullOrWhiteSpace(req.ContentType) ? null : req.ContentType;
        var startVerb = req.ScheduledEnqueueUtc.HasValue ? "Scheduling" : "Sending";
        Snackbar.Add(count == 1 ? $"{startVerb} 1 message to {targetName}..." : $"{startVerb} {count} messages to {targetName}...", Severity.Info);
        var token = StartSendCancellation();
        _ = Task.Run(async () =>
        {
            var sent = 0;
            Exception? error = null;
            var cancelled = false;
            try
            {
                for (var i = 0; i < count && !token.IsCancellationRequested; i++)
                {
                    var sched = req.ScheduledEnqueueUtc;
                    if (sched.HasValue && req.IntervalSeconds > 0)
                    {
                        sched = sched.Value.AddSeconds(req.IntervalSeconds * i);
                    }
                    await sendAsync(req, contentType, sched, token);
                    sent++;
                    if (!req.ScheduledEnqueueUtc.HasValue && req.IntervalSeconds > 0 && i < count - 1)
                    {
                        try { await Task.Delay(TimeSpan.FromSeconds(req.IntervalSeconds), token); }
                        catch (OperationCanceledException) { }
                    }
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                cancelled = true;
            }
            catch (Exception ex)
            {
                error = ex;
            }
            finally
            {
                if (!_disposed)
                {
                    var endVerb = req.ScheduledEnqueueUtc.HasValue ? "Scheduled" : "Sent";
                    await InvokeAsync(() =>
                    {
                        if (cancelled)
                        {
                            Snackbar.Add(sent > 0
                                ? $"Send cancelled after {sent} message(s) to {targetName}."
                                : $"Send cancelled for {targetName}.", Severity.Info);
                            return;
                        }
                        if (error is null)
                        {
                            Snackbar.Add(sent == 1 ? $"{endVerb} 1 message to {targetName}." : $"{endVerb} {sent} messages to {targetName}.", Severity.Success);
                        }
                        else
                        {
                            if (sent > 0)
                                Snackbar.Add($"Sent {sent} messages before failure: {error.Message}", Severity.Warning);
                            else
                                Snackbar.Add($"Failed to send: {error.Message}", Severity.Error);
                        }
                    });
                    if (CanRefreshMessages && sent > 0)
                    {
                        await RefreshActiveAsync();
                        await RefreshCountsAsync();
                        try { await InvokeAsync(StateHasChanged); }
                        catch (Exception ex)
                        {
                            Logger?.LogDebug(ex, "Failed to refresh UI after send.");
                        }
                    }
                }
            }
        }, token);
    }

    private async Task ConfirmPurgeQueue(string queueName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Purge Active Messages",
            markupMessage: (MarkupString)$"This will delete active messages from queue '<b>{queueName}</b>' (up to the configured batch). Continue?",
            yesText: "Purge",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var purged = await MessageMaintenance.PurgeQueueAsync(connectionString, queueName, maxMessages: 1000);
            Snackbar.Add($"Purged {purged} messages from {queueName}.", Severity.Success);
            await ClearActiveAfterPurgeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to purge queue: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmPurgeQueueDlq(string queueName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Purge DLQ Messages",
            markupMessage: (MarkupString)$"This will delete messages from the Dead-letter subqueue of '<b>{queueName}</b>' (up to the configured batch). Continue?",
            yesText: "Purge",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var purged = await DeadLetterMaintenance.PurgeQueueDeadLetterAsync(connectionString, queueName, maxMessages: 1000);
            Snackbar.Add($"Purged {purged} DLQ messages from {queueName}.", Severity.Success);
            await ClearDlqAfterPurgeAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to purge queue DLQ: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmReplayQueueDlq(string queueName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Replay DLQ Messages",
            markupMessage: (MarkupString)$"This will resend messages from the DLQ of '<b>{queueName}</b>' back to the active queue and complete them. Continue?",
            yesText: "Replay",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var replayed = await DeadLetterMaintenance.ReplayQueueDeadLettersAsync(connectionString, queueName, maxMessages: 50);
            Snackbar.Add($"Replayed {replayed} DLQ messages for {queueName}.", Severity.Success);
            await RefreshAfterReplayAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to replay DLQ: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmReplayQueueDlqAll(string queueName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Resubmit all DLQ messages",
            markupMessage: (MarkupString)$"This will resend <b>all</b> messages from the DLQ of '<b>{queueName}</b>' back to the active queue and remove them from the DLQ. Continue?",
            yesText: "Resubmit",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var replayed = await DeadLetterMaintenance.ReplayQueueDeadLettersAsync(connectionString, queueName, maxMessages: int.MaxValue);
            Snackbar.Add($"Resubmitted {replayed} DLQ messages for {queueName}.", Severity.Success);
            await RefreshAfterReplayAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to resubmit DLQ: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmReplaySubscriptionDlqAll(string topicName, string subscriptionName)
    {
        if (string.IsNullOrWhiteSpace(_connectionString)) return;
        var confirm = await DialogService.ShowMessageBox(
            title: "Resubmit all DLQ messages",
            markupMessage: (MarkupString)$"This will resend <b>all</b> messages from the DLQ of '<b>{topicName}/{subscriptionName}</b>' back to the topic and remove them from the DLQ. Continue?",
            yesText: "Resubmit",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            var connectionString = _connectionString!;
            var replayed = await DeadLetterMaintenance.ReplaySubscriptionDeadLettersAsync(connectionString, topicName, subscriptionName, maxMessages: int.MaxValue);
            Snackbar.Add($"Resubmitted {replayed} DLQ messages for {topicName}/{subscriptionName}.", Severity.Success);
            await RefreshAfterReplayAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to resubmit DLQ: {ex.Message}", Severity.Error);
        }
    }

    // Selection helpers and action bar commands
    private bool HasConnection => !string.IsNullOrWhiteSpace(_connectionString);
    private bool SelectedIsQueue => _selectedTreeValue?.StartsWith("queue:", StringComparison.OrdinalIgnoreCase) == true;
    private bool SelectedIsTopic => _selectedTreeValue?.StartsWith("topic:", StringComparison.OrdinalIgnoreCase) == true;
    private bool SelectedIsSubscription => _selectedTreeValue?.StartsWith("subscription:", StringComparison.OrdinalIgnoreCase) == true;
    private bool SelectedIsRoot => string.Equals(_selectedTreeValue, "root", StringComparison.OrdinalIgnoreCase);
    private bool SelectedIsQueuesFolder => string.Equals(_selectedTreeValue, "queues", StringComparison.OrdinalIgnoreCase);
    private bool SelectedIsTopicsFolder => string.Equals(_selectedTreeValue, "topics", StringComparison.OrdinalIgnoreCase);

    private bool CanPeek => HasConnection && (SelectedIsQueue || SelectedIsSubscription);
    private bool CanPeekDlq => HasConnection && (SelectedIsQueue || SelectedIsSubscription);
    private bool CanSend => HasConnection && (SelectedIsQueue || SelectedIsTopic);
    private bool CanPurgeActive => HasConnection && (SelectedIsQueue || SelectedIsSubscription);
    private bool CanPurgeDlq => HasConnection && (SelectedIsQueue || SelectedIsSubscription);
    private bool CanResubmitDlq => HasConnection && (SelectedIsQueue || SelectedIsSubscription) && (_dlqCount ?? 0) > 0;
    private bool CanCreateSubscriptionAction => HasConnection && SelectedIsTopic && !_creatingSubscription;
    private bool CanDeleteSubscriptionAction => HasConnection && SelectedIsSubscription;
    private bool CanCreateQueueAction => HasConnection;
    private bool CanCreateTopicAction => HasConnection;
    private bool CanDeleteQueueAction => HasConnection && SelectedIsQueue;
    private bool CanDeleteTopicAction => HasConnection && SelectedIsTopic;

    private string SelectedFriendly
    {
        get
        {
            if (string.IsNullOrEmpty(_selectedTreeValue)) return "(none)";
            if (SelectedIsQueue) return $"Queue '{_selectedTreeValue.Substring("queue:".Length)}'";
            if (SelectedIsTopic) return $"Topic '{_selectedTreeValue.Substring("topic:".Length)}'";
            if (SelectedIsSubscription) return $"Subscription '{_selectedTreeValue.Substring("subscription:".Length)}'";
            return _selectedTreeValue!;
        }
    }

    private bool TryGetQueue(out string name)
    {
        name = string.Empty;
        if (!SelectedIsQueue || string.IsNullOrEmpty(_selectedTreeValue)) return false;
        name = _selectedTreeValue["queue:".Length..];
        return !string.IsNullOrWhiteSpace(name);
    }

    private bool TryGetTopic(out string name)
    {
        name = string.Empty;
        if (!SelectedIsTopic || string.IsNullOrEmpty(_selectedTreeValue)) return false;
        name = _selectedTreeValue["topic:".Length..];
        return !string.IsNullOrWhiteSpace(name);
    }

    private bool TryGetSubscription(out string topic, out string subscription)
    {
        topic = string.Empty;
        subscription = string.Empty;
        if (!SelectedIsSubscription || string.IsNullOrEmpty(_selectedTreeValue)) return false;
        var payload = _selectedTreeValue["subscription:".Length..];
        var parts = payload.Split('/', 2);
        if (parts.Length != 2) return false;
        topic = parts[0];
        subscription = parts[1];
        return !string.IsNullOrWhiteSpace(topic) && !string.IsNullOrWhiteSpace(subscription);
    }

    private async Task RefreshEntities()
    {
        if (HasConnection)
            await LoadEntities();
    }

    

    

    private async Task SendToSelected()
    {
        if (!HasConnection) return;
        if (TryGetQueue(out var q))
        {
            await OpenSendToQueue(q);
        }
        else if (TryGetTopic(out var t))
        {
            await OpenSendToTopic(t);
        }
    }

    private async Task PurgeActiveSelected()
    {
        if (!HasConnection) return;
        if (TryGetQueue(out var q))
        {
            await ConfirmPurgeQueue(q);
        }
        else if (TryGetSubscription(out var t, out var s))
        {
            await ConfirmPurgeSubscription(t, s);
        }
    }

    private async Task PurgeDlqSelected()
    {
        if (!HasConnection) return;
        if (TryGetQueue(out var q))
        {
            await ConfirmPurgeQueueDlq(q);
        }
        else if (TryGetSubscription(out var t, out var s))
        {
            await ConfirmPurgeSubscriptionDlq(t, s);
        }
    }

    private async Task ResubmitDlqSelected()
    {
        if (!HasConnection) return;
        if (TryGetQueue(out var q))
        {
            await ConfirmReplayQueueDlqAll(q);
        }
        else if (TryGetSubscription(out var t, out var s))
        {
            await ConfirmReplaySubscriptionDlqAll(t, s);
        }
    }

    // Tree selection change -> load settings for selected entity
    private async Task OnTreeSelectionChanged(string? value)
    {
        // Clicking the top-level folders should expand them instead of changing selection
        if (string.Equals(value, "queues", StringComparison.OrdinalIgnoreCase))
        {
            _queuesExpanded = !_queuesExpanded;
            await InvokeAsync(StateHasChanged);
            return;
        }
        if (string.Equals(value, "topics", StringComparison.OrdinalIgnoreCase))
        {
            _topicsExpanded = !_topicsExpanded;
            await InvokeAsync(StateHasChanged);
            return;
        }

        // Toggle expand for individual topics to reveal subscriptions
        if (!string.IsNullOrWhiteSpace(value) && value.StartsWith("topic:", StringComparison.OrdinalIgnoreCase))
        {
            var name = value.Substring("topic:".Length);
            if (!string.IsNullOrWhiteSpace(name))
            {
                if (_expandedTopicNames.Contains(name)) _expandedTopicNames.Remove(name); else _expandedTopicNames.Add(name);
            }
        }

        _selectedTreeValue = value;
        // stop live polling and clear lists on entity switch
        StopLiveActive();
        StopLiveDlq();
        StopCountsPolling();
        _activeMessages.Clear();
        _dlqMessages.Clear();
        // Reset anchors and paging history for new selection
        _activeAnchor = null;
        _dlqAnchor = null;
        _activeHistory.Clear();
        _dlqHistory.Clear();
        await LoadSettingsForSelection();
        await LoadRulesForSelection();
        await RefreshCountsAsync();
        StartCountsPolling();
        // auto-load message lists for the new selection
        await RefreshActiveAsync();
        await RefreshDlqAsync();
        StateHasChanged();
    }

    private async Task LoadSettingsForSelection()
    {
        _ttlText = string.Empty;
        _deadLetterOnExpiration = false;
        if (!HasConnection || string.IsNullOrEmpty(_selectedTreeValue)) return;
        try
        {
            _settingsLoading = true;
            if (TryGetQueue(out var q))
            {
                var s = await QueueAdmin.GetQueueSettingsAsync(_connectionString!, q);
                _ttlText = FormatTimeSpan(s.DefaultMessageTimeToLive);
                _deadLetterOnExpiration = s.DeadLetteringOnMessageExpiration;
                _lockDurationText = FormatTimeSpan(s.LockDuration);
                _maxDeliveryCount = s.MaxDeliveryCount;
                _enableBatchedOperations = s.EnableBatchedOperations;
                _forwardTo = s.ForwardTo;
                _forwardDeadLetteredTo = s.ForwardDeadLetteredMessagesTo;
            }
            else if (TryGetTopic(out var t))
            {
                var s = await TopicAdmin.GetTopicSettingsAsync(_connectionString!, t);
                _ttlText = FormatTimeSpan(s.DefaultMessageTimeToLive);
                _enableBatchedOperations = s.EnableBatchedOperations;
                _lockDurationText = string.Empty;
                _maxDeliveryCount = 10;
                _forwardTo = null;
                _forwardDeadLetteredTo = null;
                _requiresSession = false;
            }
            else if (TryGetSubscription(out var topic, out var sub))
            {
                var s = await SubscriptionAdmin.GetSubscriptionSettingsAsync(_connectionString!, topic, sub);
                _ttlText = FormatTimeSpan(s.DefaultMessageTimeToLive);
                _deadLetterOnExpiration = s.DeadLetteringOnMessageExpiration;
                _requiresSession = s.RequiresSession;
                _lockDurationText = FormatTimeSpan(s.LockDuration);
                _maxDeliveryCount = s.MaxDeliveryCount;
                _enableBatchedOperations = s.EnableBatchedOperations;
                _forwardTo = s.ForwardTo;
                _forwardDeadLetteredTo = s.ForwardDeadLetteredMessagesTo;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load settings: {ex.Message}", Severity.Error);
        }
        finally
        {
            _settingsLoading = false;
        }
    }

    private static string FormatTimeSpan(TimeSpan ts) => ts.ToString("c");

    private static string FormatCount(long? count) => count.HasValue ? count.Value.ToString("N0") : "-";

    private bool TryParseTtl(out TimeSpan ttl) => TimeSpanParser.TryParse(_ttlText, out ttl);

    private bool CanSaveSettings => HasConnection && !string.IsNullOrEmpty(_selectedTreeValue) && !_settingsSaving && !_settingsLoading && TryParseTtl(out _);

    private bool CanRefreshMessages => HasConnection && (SelectedIsQueue || SelectedIsSubscription);

    private async Task SaveSettingsAsync()
    {
        if (!HasConnection || string.IsNullOrEmpty(_selectedTreeValue)) return;
        if (!TryParseTtl(out var ttl))
        {
            Snackbar.Add("Invalid TTL format. Use d.hh:mm:ss (e.g., 1.00:00:00) or standard TimeSpan format.", Severity.Warning);
            return;
        }
        try
        {
            _settingsSaving = true;
            if (TryGetQueue(out var q))
            {
                await QueueAdmin.UpdateQueueSettingsAsync(_connectionString!, q, ttl, _deadLetterOnExpiration);
                // Advanced properties
                if (!TryParseTtlString(_lockDurationText, out var lockDuration))
                {
                    Snackbar.Add("Invalid Lock Duration. Use d.hh:mm:ss (e.g., 00:01:00).", Severity.Warning);
                    return;
                }
                var sanitizedMaxDelivery = Math.Max(1, _maxDeliveryCount);
                var forwardTo = string.IsNullOrWhiteSpace(_forwardTo) ? null : _forwardTo.Trim();
                var forwardDeadLetteredTo = string.IsNullOrWhiteSpace(_forwardDeadLetteredTo) ? null : _forwardDeadLetteredTo.Trim();
                await QueueAdmin.UpdateQueuePropertiesAsync(
                    _connectionString!,
                    q,
                    lockDuration,
                    sanitizedMaxDelivery,
                    _enableBatchedOperations,
                    forwardTo,
                    forwardDeadLetteredTo);
            }
            else if (TryGetTopic(out var t))
            {
                await TopicAdmin.UpdateTopicSettingsAsync(_connectionString!, t, ttl);
                // Advanced properties
                await TopicAdmin.UpdateTopicPropertiesAsync(_connectionString!, t, _enableBatchedOperations);
            }
            else if (TryGetSubscription(out var topic, out var sub))
            {
                await SubscriptionAdmin.UpdateSubscriptionSettingsAsync(_connectionString!, topic, sub, ttl, _deadLetterOnExpiration);
                // Advanced properties
                if (!TryParseTtlString(_lockDurationText, out var lockDuration))
                {
                    Snackbar.Add("Invalid Lock Duration. Use d.hh:mm:ss (e.g., 00:01:00).", Severity.Warning);
                    return;
                }
                var sanitizedMaxDelivery = Math.Max(1, _maxDeliveryCount);
                var forwardTo = string.IsNullOrWhiteSpace(_forwardTo) ? null : _forwardTo.Trim();
                var forwardDeadLetteredTo = string.IsNullOrWhiteSpace(_forwardDeadLetteredTo) ? null : _forwardDeadLetteredTo.Trim();
                await SubscriptionAdmin.UpdateSubscriptionPropertiesAsync(
                    _connectionString!,
                    topic,
                    sub,
                    _requiresSession,
                    lockDuration,
                    sanitizedMaxDelivery,
                    _enableBatchedOperations,
                    forwardTo,
                    forwardDeadLetteredTo);
            }
            // Reload to reflect authoritative values from the server (SDK may coerce TTL)
            await LoadSettingsForSelection();
            Snackbar.Add("Settings saved.", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to save settings: {ex.Message}", Severity.Error);
        }
        finally
        {
            _settingsSaving = false;
        }
    }

    private async Task ReloadSettingsAsync()
    {
        await LoadSettingsForSelection();
    }

    private bool CanRefreshRules => HasConnection && SelectedIsSubscription;

    private async Task LoadRulesForSelection()
    {
        _rules.Clear();
        if (!HasConnection || string.IsNullOrEmpty(_selectedTreeValue)) return;
        if (!TryGetSubscription(out var topic, out var sub)) return;
        try
        {
            _rulesLoading = true;
            var items = await SubscriptionRuleAdmin.ListSubscriptionRulesAsync(_connectionString!, topic, sub);
            _rules = items.ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load rules: {ex.Message}", Severity.Error);
        }
        finally
        {
            _rulesLoading = false;
        }
    }

    private async Task RefreshRulesAsync()
    {
        await LoadRulesForSelection();
    }

    private async Task CreateSubscriptionAsync()
    {
        if (!SelectedIsTopic || string.IsNullOrWhiteSpace(_connectionString)) return;
        if (!TryGetTopic(out var topicName)) return;
        var parameters = new DialogParameters
        {
            ["Title"] = $"Create subscription for '{topicName}'"
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<CreateSubscriptionDialog>("Create Subscription", parameters, options);
        var result = await dialog.Result;
        if (result is not { Canceled: false, Data: CreateSubscriptionRequest req }) return;
        var subName = req.Name?.Trim() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(subName)) return;
        try
        {
            _creatingSubscription = true;
            await SubscriptionAdmin.CreateSubscriptionAsync(_connectionString!, topicName, subName);
            // Optionally apply settings from the dialog
            TimeSpan ttlToSet;
            try
            {
                if (!TryParseTtlString(req.TtlText, out var parsed))
                {
                    var current = await SubscriptionAdmin.GetSubscriptionSettingsAsync(_connectionString!, topicName, subName);
                    ttlToSet = current.DefaultMessageTimeToLive;
                }
                else ttlToSet = parsed;
            }
            catch (Exception ex)
            {
                Logger?.LogWarning(ex, "Failed to resolve subscription TTL for {TopicName}/{SubscriptionName}; using default.", topicName, subName);
                ttlToSet = TimeSpan.FromDays(14); // harmless fallback
            }
            try
            {
                await SubscriptionAdmin.UpdateSubscriptionSettingsAsync(_connectionString!, topicName, subName, ttlToSet, req.DeadLetterOnExpiration);
            }
            catch (Exception ex)
            {
                Logger?.LogWarning(ex, "Failed to apply subscription settings for {TopicName}/{SubscriptionName}.", topicName, subName);
            }

            // Apply advanced properties
            try
            {
                // Parse lock duration; fallback to 1 minute
                var lockDuration = TimeSpan.FromMinutes(1);
                if (TryParseTtlString(req.LockDurationText, out var parsedLock))
                    lockDuration = parsedLock;
                await SubscriptionAdmin.UpdateSubscriptionPropertiesAsync(
                    _connectionString!,
                    topicName,
                    subName,
                    req.RequiresSession,
                    lockDuration,
                    Math.Max(1, req.MaxDeliveryCount),
                    req.EnableBatchedOperations,
                    req.ForwardTo,
                    req.ForwardDeadLetteredMessagesTo);
            }
            catch (Exception ex)
            {
                Logger?.LogWarning(ex, "Failed to apply subscription properties for {TopicName}/{SubscriptionName}.", topicName, subName);
            }

            // Replace default rule with custom SQL if requested
            if (string.Equals(req.InitialRuleMode, "Sql", StringComparison.OrdinalIgnoreCase)
                && !string.IsNullOrWhiteSpace(req.InitialRuleSql))
            {
                try
                {
                    // Delete default match-all rule, then create SQL rule using the default name
                    try { await SubscriptionRuleAdmin.DeleteSubscriptionRuleAsync(_connectionString!, topicName, subName, "$Default"); }
                    catch (Exception ex)
                    {
                        Logger?.LogWarning(ex, "Failed to delete default rule for {TopicName}/{SubscriptionName}.", topicName, subName);
                    }
                    await SubscriptionRuleAdmin.CreateSubscriptionSqlRuleAsync(_connectionString!, topicName, subName, "$Default", req.InitialRuleSql!, req.InitialRuleSqlAction);
                }
                catch (Exception ex)
                {
                    Logger?.LogWarning(ex, "Failed to apply initial SQL rule for {TopicName}/{SubscriptionName}.", topicName, subName);
                    Snackbar.Add("Created subscription, but failed to apply initial SQL rule.", Severity.Warning);
                }
            }
            Snackbar.Add($"Subscription '{subName}' created on topic '{topicName}'.", Severity.Success);
            // Refresh this topic's subscription list in the tree
            var subs = await SubscriptionAdmin.ListSubscriptionsAsync(_connectionString!, topicName);
            _topicSubscriptions[topicName] = subs;
            // Ensure the topic is expanded and select the new subscription
            _expandedTopicNames.Add(topicName);
            await OnTreeSelectionChanged($"subscription:{topicName}/{subName}");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create subscription: {ex.Message}", Severity.Error);
        }
        finally
        {
            _creatingSubscription = false;
        }
    }

    private static bool TryParseTtlString(string? text, out TimeSpan ttl) => TimeSpanParser.TryParse(text, out ttl);

    private async Task CreateQueueAsync()
    {
        if (!HasConnection) return;
        var parameters = new DialogParameters { ["Title"] = "Create Queue" };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<CreateQueueDialog>("Create Queue", parameters, options);
        var result = await dialog.Result;
        if (result is not { Canceled: false, Data: CreateQueueRequest req }) return;
        var name = req.Name?.Trim();
        if (string.IsNullOrWhiteSpace(name)) return;
        try
        {
            // Parse TTL and LockDuration
            TimeSpan? ttlOpt = null;
            if (TryParseTtlString(req.TtlText, out var parsedTtl)) ttlOpt = parsedTtl;
            var lockDuration = TimeSpan.FromMinutes(1);
            if (TryParseTtlString(req.LockDurationText, out var parsedLock)) lockDuration = parsedLock;

            await QueueAdmin.CreateQueueAsync(
                _connectionString!,
                name,
                req.RequiresSession,
                lockDuration,
                Math.Max(1, req.MaxDeliveryCount),
                req.EnableBatchedOperations,
                ttlOpt,
                req.DeadLetterOnExpiration,
                req.ForwardTo,
                req.ForwardDeadLetteredMessagesTo);
            Snackbar.Add($"Queue '{name}' created.", Severity.Success);
            // Refresh and select
            _queues = await QueueAdmin.ListQueuesAsync(_connectionString!);
            _selectedTreeValue = $"queue:{name}";
            await LoadSettingsForSelection();
            await RefreshActiveAsync();
            await RefreshDlqAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create queue: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateTopicAsync()
    {
        if (!HasConnection) return;
        var parameters = new DialogParameters { ["Title"] = "Create Topic" };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<CreateTopicDialog>("Create Topic", parameters, options);
        var result = await dialog.Result;
        if (result is not { Canceled: false, Data: CreateTopicRequest req }) return;
        var name = req.Name?.Trim();
        if (string.IsNullOrWhiteSpace(name)) return;
        try
        {
            await TopicAdmin.CreateTopicAsync(_connectionString!, name);
            // Apply TTL
            var ttlToSet = TimeSpan.FromDays(14);
            if (TryParseTtlString(req.TtlText, out var parsedTtl)) ttlToSet = parsedTtl;
            try { await TopicAdmin.UpdateTopicSettingsAsync(_connectionString!, name, ttlToSet); }
            catch (Exception ex)
            {
                Logger?.LogWarning(ex, "Failed to apply topic settings for {TopicName}.", name);
            }
            // Advanced
            try { await TopicAdmin.UpdateTopicPropertiesAsync(_connectionString!, name, req.EnableBatchedOperations); }
            catch (Exception ex)
            {
                Logger?.LogWarning(ex, "Failed to apply topic properties for {TopicName}.", name);
            }
            Snackbar.Add($"Topic '{name}' created.", Severity.Success);
            // Refresh and select
            _topics = await TopicAdmin.ListTopicsAsync(_connectionString!);
            _expandedTopicNames.Add(name);
            _selectedTreeValue = $"topic:{name}";
            await LoadSettingsForSelection();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create topic: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteSelectedQueueAsync()
    {
        if (!SelectedIsQueue || string.IsNullOrWhiteSpace(_connectionString)) return;
        var name = _selectedTreeValue!["queue:".Length..];
        var confirm = await DialogService.ShowMessageBox(
            title: "Delete Queue",
            markupMessage: (MarkupString)$"This will permanently delete queue '<b>{name}</b>'. Continue?",
            yesText: "Delete",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            await QueueAdmin.DeleteQueueAsync(_connectionString!, name);
            Snackbar.Add($"Queue '{name}' deleted.", Severity.Success);
            await LoadEntities();
            _selectedTreeValue = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete queue: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteSelectedTopicAsync()
    {
        if (!SelectedIsTopic || string.IsNullOrWhiteSpace(_connectionString)) return;
        var name = _selectedTreeValue!["topic:".Length..];
        var confirm = await DialogService.ShowMessageBox(
            title: "Delete Topic",
            markupMessage: (MarkupString)$"This will permanently delete topic '<b>{name}</b>' and all its subscriptions. Continue?",
            yesText: "Delete",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small });
        if (confirm != true) return;
        try
        {
            await TopicAdmin.DeleteTopicAsync(_connectionString!, name);
            Snackbar.Add($"Topic '{name}' deleted.", Severity.Success);
            await LoadEntities();
            _selectedTreeValue = null;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete topic: {ex.Message}", Severity.Error);
        }
    }

    private async Task CreateRuleAsync()
    {
        if (!CanRefreshRules) return;
        var title = SelectedFriendly is { } s ? $"Create Rule - {s}" : "Create Rule";
        var parameters = new DialogParameters
        {
            ["Title"] = title
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<CreateRuleDialog>("Create Rule", parameters, options);
        var result = await dialog.Result;
        if (result is { Canceled: false, Data: not null })
        {
            try
            {
                if (!TryGetSubscription(out var topic, out var sub)) return;
                switch (result.Data)
                {
                    case CreateSqlRuleRequest sql:
                        await SubscriptionRuleAdmin.CreateSubscriptionSqlRuleAsync(_connectionString!, topic, sub, sql.Name, sql.SqlExpression, sql.SqlAction);
                        Snackbar.Add($"Rule '{sql.Name}' created.", Severity.Success);
                        break;
                    case CreateCorrelationRuleRequest corr:
                        await SubscriptionRuleAdmin.CreateSubscriptionCorrelationRuleAsync(
                            _connectionString!, topic, sub, corr.Name,
                            corr.CorrelationId, corr.Subject, corr.To, corr.ReplyTo,
                            corr.ReplyToSessionId, corr.SessionId, corr.ContentType,
                            corr.ApplicationProperties);
                        Snackbar.Add($"Rule '{corr.Name}' created.", Severity.Success);
                        break;
                    default:
                        return;
                }
                await RefreshRulesAsync();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to create rule: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task DeleteRuleAsync(SubscriptionRuleInfo rule)
    {
        if (!CanRefreshRules) return;
        if (_rules.Count <= 1)
        {
            Snackbar.Add("Cannot delete the only rule on a subscription.", Severity.Warning);
            return;
        }
        var confirm = await DialogService.ShowMessageBox(
            title: "Delete Rule",
            markupMessage: (MarkupString)$"Are you sure you want to delete rule '<b>{rule.Name}</b>'?",
            yesText: "Delete",
            cancelText: "Cancel",
            options: new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.ExtraSmall });
        if (confirm != true) return;
        try
        {
            if (!TryGetSubscription(out var topic, out var sub)) return;
            await SubscriptionRuleAdmin.DeleteSubscriptionRuleAsync(_connectionString!, topic, sub, rule.Name);
            Snackbar.Add($"Rule '{rule.Name}' deleted.", Severity.Success);
            await RefreshRulesAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete rule: {ex.Message}", Severity.Error);
        }
    }
}
